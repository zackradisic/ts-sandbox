export const starterCode = "type Pixel = number[];\r\ntype Row = Pixel[];\r\ntype Image = Row[];\r\n\r\nconst swapPixels = (image: Image, [x0, y0]: number[], [x1, y1]: number[]) => {\r\n  [image[x0][y0], image[x1][y1]] = [image[x1][y1], image[x0][y0]];\r\n};\r\n\r\nfunction rotate90deg(image: Image) {\r\n  const layers = Math.floor(image.length \/ 2);\r\n  for (let first = 0; first < layers; first++) {\r\n    const last = image.length - first - 1;\r\n    for (let i = 0; i < last - first; i++) {\r\n      const topPixel = [first, i + first];\r\n      swapPixels(image, topPixel, [i + first, last]); \/\/ Swap top with right\r\n      swapPixels(image, topPixel, [last, last - i]); \/\/ Swap top with bottom\r\n      swapPixels(image, topPixel, [last - i, first]); \/\/ Swap top with left\r\n    }\r\n  }\r\n  return image;\r\n}\r\n\r\nfunction isPalindromeAfterPermutation(str: string) {\r\n  const charCount = new Map();\r\n  for (const char of str.toLowerCase()) {\r\n    if (char === \' \') continue;\r\n    charCount.set(char, (charCount.get(char) || 0) + 1);\r\n  }\r\n  return Array.from(charCount.values()).filter(v => v % 2 !== 0).length <= 1;\r\n}\r\n\r\nfunction isOneEditAway(a: string, b: string) {\r\n  if (a === b) return true;\r\n  if (Math.abs(a.length - b.length) >= 2) return false;\r\n\r\n  const longerStr = a.length > b.length ? a : b;\r\n  const shorterStr = a.length > b.length ? b : a;\r\n\r\n  for (let i = 0; i < longerStr.length; i++) {\r\n    if (shorterStr[i] !== longerStr[i]) {\r\n      const insertOrReplace = longerStr.length === shorterStr.length ? 1 : 0;\r\n      const postEditShorterStr =\r\n        shorterStr.substring(0, i) +\r\n        longerStr[i] +\r\n        shorterStr.substring(i + insertOrReplace);\r\n      return longerStr === postEditShorterStr;\r\n    }\r\n  }\r\n\r\n  \/\/ This will never happen.\r\n  \/\/ Just needed to prevent TS Error: \"Not all code paths return a value\"\r\n  return true;\r\n}\r\n\r\nfunction setZeros(matrix: number[][]) {\r\n  const rows = matrix.length;\r\n  const cols = matrix[0].length;\r\n\r\n  const zeroMarkedRows = Array(rows).fill(false);\r\n  const zeroMarkedCols = Array(cols).fill(false);\r\n\r\n  for (let row = 0; row < rows; row++) {\r\n    for (let col = 0; col < cols; col++) {\r\n      if (matrix[row][col] === 0) {\r\n        zeroMarkedRows[row] = true;\r\n        zeroMarkedCols[col] = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  for (let row = 0; row < rows; row++) {\r\n    if (zeroMarkedRows[row]) matrix[row].fill(0);\r\n  }\r\n\r\n  for (let col = 0; col < cols; col++) {\r\n    if (zeroMarkedCols[col]) {\r\n      for (let row = 0; row < cols; row++) {\r\n        matrix[row][col] = 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  return matrix;\r\n}\r\n\r\nfunction bitInsertion(\r\n  base: string,\r\n  inserted: string,\r\n  i: number,\r\n  j: number,\r\n) {\r\n  const baseNum = parseInt(base, 2);\r\n  const insertedNum = parseInt(inserted, 2);\r\n\r\n  \/\/ Check given assumptions\r\n  if (i > j || inserted.length - 1 > j - i) {\r\n    throw new Error(`Impossible to insert ${inserted}!`);\r\n  }\r\n\r\n  const maskMsbToJ = (1 << j) - 1;\r\n  const maskITo0 = (-1 << (i + 1)) - 1;\r\n  const baseWithJToICleared = baseNum & (maskMsbToJ | maskITo0);\r\n\r\n  const ans = (baseWithJToICleared | (insertedNum << i))\r\n  return ans.toString(2);\r\n}\r\n\r\nfunction binaryToString(realNumber: number) {\r\n  \/\/ Check given assumptions\r\n  if (realNumber <= 0 || realNumber >= 1) {\r\n    throw new Error(`Number ${realNumber} is not in the range 0-1.`);\r\n  }\r\n\r\n  let binaryFraction = \'\';\r\n  let chipAwayNumber = realNumber;\r\n  while (chipAwayNumber > 0) {\r\n    if (binaryFraction.length > 32) return \'ERROR\';\r\n\r\n    const shiftBinaryLeft = chipAwayNumber * 2;\r\n    binaryFraction += shiftBinaryLeft >= 1 ? \'1\' : \'0\';\r\n    chipAwayNumber = shiftBinaryLeft - (shiftBinaryLeft >= 1 ? 1 : 0);\r\n  }\r\n\r\n  return binaryFraction;\r\n}\r\n\r\n   \r\nconst bitsInJavaScriptNumber = 64;\r\n\r\nfunction flipBitToWin(num: number) {\r\n  let preZeroLength = 0;\r\n  let postZeroLength = 0;\r\n  let haveSeenZero = false;\r\n  let longestFound = 0;\r\n\r\n  for (let i = 0; i < bitsInJavaScriptNumber; i++) {\r\n    const curBit = (num & (1 << i)) !== 0;\r\n    if (curBit) {\r\n      haveSeenZero ? postZeroLength++ : preZeroLength++;\r\n      longestFound = Math.max(longestFound, preZeroLength + postZeroLength);\r\n    } else {\r\n      if (haveSeenZero) {\r\n        [preZeroLength, postZeroLength] = [postZeroLength, 0];\r\n      } else {\r\n        haveSeenZero = true;\r\n      }\r\n      preZeroLength++; \/\/ Increment for now flipped 0\r\n    }\r\n  }\r\n\r\n  return longestFound;\r\n}\r\n\r\nfunction findLarger(num: number) {\r\n  let c = num;\r\n  let c0 = 0;\r\n  let c1 = 0;\r\n\r\n  while ((c & 1) === 0 && c !== 0) {\r\n    c0++;\r\n    c >>= 1;\r\n  }\r\n\r\n  while ((c & 1) === 1) {\r\n    c1++;\r\n    c >>= 1;\r\n  }\r\n\r\n  if (c0 + c1 === bitsInJavaScriptNumber \/ 2 - 1 || c0 + c1 === 0) {\r\n    throw new Error(\'No larger number can be made with the same number of 1s.\');\r\n  }\r\n\r\n  const p = c0 + c1;\r\n\r\n  num |= 1 << p;\r\n  num &= ~((1 << p) - 1);\r\n  num |= (1 << (c1 - 1)) - 1;\r\n\r\n  return num;\r\n}\r\n\r\nfunction findSmaller(num: number) {\r\n  let c = num;\r\n  let c0 = 0;\r\n  let c1 = 0;\r\n\r\n  while ((c & 1) === 1) {\r\n    c1++;\r\n    c >>= 1;\r\n  }\r\n\r\n  if (c === 0) {\r\n    throw new Error(\'No larger number can be made with the same number of 1s.\');\r\n  }\r\n\r\n  while ((c & 1) === 0 && c !== 0) {\r\n    c0++;\r\n    c >>= 1;\r\n  }\r\n\r\n  const p = c0 + c1;\r\n\r\n  num &= ~0 << (p + 1);\r\n\r\n  const mask = (1 << (c1 + 1)) - 1;\r\n  num |= mask << (c0 - 1);\r\n\r\n  return num;\r\n}\r\n\r\nconst flipRightmost = {\r\n  larger: findLarger,\r\n  smaller: findSmaller,\r\n};\r\n\r\nfunction howManyFlipsWithMath(a: number, b: number) {\r\n  let xor = a ^ b;\r\n  let bitCount = 0;\r\n  while (xor !== 0) {\r\n    xor -= 2 ** Math.floor(Math.log2(xor));\r\n    bitCount++;\r\n  }\r\n  return bitCount;\r\n}\r\n\r\nfunction howManyFlipsWithShift(a: number, b: number) {\r\n  let bitCount = 0;\r\n  for (let c = a ^ b; c !== 0; c = c >>> 1) bitCount += c & 1;\r\n  return bitCount;\r\n}\r\n\r\nfunction howManyFlipsWithMask(a: number, b: number) {\r\n  let bitCount = 0;\r\n  for (let c = a ^ b; c !== 0; c = c & (c - 1)) bitCount++;\r\n  return bitCount;\r\n}\r\n\r\nconst bytesInJsBitwiseOperands = 32 \/ 3;\r\n\r\nfunction oddEvenSwapByShift(num: number) {\r\n  const evenMask = parseInt(\'5\'.repeat(bytesInJsBitwiseOperands), 16);\r\n  const oddMask = parseInt(\'A\'.repeat(bytesInJsBitwiseOperands), 16);\r\n  const evenShiftedLeft = (num & evenMask) << 1;\r\n  const oddShiftedRight = (num & oddMask) >>> 1;\r\n  return evenShiftedLeft | oddShiftedRight;\r\n}\r\n\r\nfunction drawLine(\r\n  screen: Uint8Array,\r\n  width: number,\r\n  x1: number,\r\n  x2: number,\r\n  y: number,\r\n) {\r\n  const firstByte = (width \/ 8) * y + Math.floor(x1 \/ 8);\r\n  const lastByte = (width \/ 8) * y + Math.floor(x2 \/ 8);\r\n\r\n  for (let byte = firstByte + 1; byte < lastByte; byte++) screen[byte] = 0xff;\r\n\r\n  const i = x1 % 8;\r\n  const j = x2 % 8;\r\n\r\n  const firstMask = 0xff >> i;\r\n  const lastMask = ~(0xff >> (j + 1));\r\n\r\n  if (firstByte === lastByte) {\r\n    const firstLastMask = firstMask & lastMask;\r\n    screen[firstByte] = screen[firstByte] | (0xff & firstLastMask);\r\n  } else {\r\n    screen[firstByte] = i === 0 ? 0xff : screen[firstByte] | (0xff & firstMask);\r\n    screen[lastByte] = j === 0 ? 0xff : screen[lastByte] | (0xff & lastMask);\r\n  }\r\n\r\n  return screen;\r\n}\r\n\r\nenum Suit {\r\n  Spades,\r\n  Clubs,\r\n  Diamonds,\r\n  Hearts,\r\n}\r\nenum Rank {\r\n  Ace = 1,\r\n  Two,\r\n  Three,\r\n  Four,\r\n  Five,\r\n  Six,\r\n  Seven,\r\n  Eight,\r\n  Nine,\r\n  Ten,\r\n  Jack,\r\n  Queen,\r\n  King,\r\n}\r\n\r\nclass Card {\r\n  constructor(readonly suit: Suit, readonly rank: Rank) {}\r\n}\r\n\r\nclass Deck {\r\n  constructor(private cards: Card[] = []) {\r\n    for (const suit of (Object.keys(Suit) as unknown) as Suit[]) {\r\n      for (const rank of (Object.keys(Rank) as unknown) as Rank[]) {\r\n        this.cards.push(new Card(suit, rank));\r\n      }\r\n    }\r\n  }\r\n\r\n  shuffle() {\r\n    this.cards.sort(() => (Math.random() > 0.5 ? 1 : -1));\r\n  }\r\n  deal = () => this.cards.pop();\r\n}\r\n\r\nclass Hand {\r\n  private cards: Card[] = [];\r\n  receiveCard(dealtCard: Card) {\r\n    this.cards.push(dealtCard);\r\n  }\r\n}\r\n\r\ntype PlayerId = string;\r\nclass BlackjackTable {\r\n  private dealer = {\r\n    deck: new Deck(),\r\n    hand: new Hand(),\r\n  };\r\n  private players: { [plyId: string]: Hand } = {};\r\n\r\n  addPlayer(player: PlayerId) {\r\n    this.players[player] = new Hand();\r\n  }\r\n  playGame() {\r\n    if (Object.keys(this.players.length).length === 0) {\r\n      throw new Error(\'Blackjack needs players\');\r\n    }\r\n\r\n    this.dealer.deck.shuffle();\r\n    for (let i = 0; i < 2; i++) {\r\n      Object.values(this.players).forEach(player => {\r\n        player.receiveCard(this.dealer.deck.deal()!);\r\n      });\r\n      this.dealer.hand.receiveCard(this.dealer.deck.deal()!);\r\n    }\r\n  }\r\n}\r\n\r\ninterface ICall {\r\n  subject: string;\r\n}\r\n\r\nabstract class Employee {\r\n  static seniors: Employee[];\r\n\r\n  constructor(readonly name: string, private isFreeInternal: boolean = true) {}\r\n\r\n  receiveCall(call: ICall) {\r\n    this.isFreeInternal = false;\r\n    if (this.canHandleCall(call)) {\r\n      this.handleCall(call);\r\n    } else {\r\n      this.escalateCall(call);\r\n    }\r\n    this.isFreeInternal = true;\r\n  }\r\n\r\n  isFree = () => this.isFreeInternal;\r\n\r\n  protected escalateCall(call: ICall) {\r\n    const senior = this.getSeniors().find(s => s.isFreeInternal);\r\n    if (senior) {\r\n      senior.receiveCall(call);\r\n    } else {\r\n      console.log(\'Cannot find senior employee to handle call.\');\r\n    }\r\n  }\r\n\r\n  protected abstract getSeniors(): Employee[];\r\n  protected abstract canHandleCall(call: ICall): boolean;\r\n  protected abstract handleCall(call: ICall): void;\r\n}\r\n\r\nclass Respondent extends Employee {\r\n  static seniors: Manager[];\r\n\r\n  protected getSeniors = () => Respondent.seniors;\r\n  protected canHandleCall = () => Math.random() > 0.5;\r\n  protected handleCall = () => console.log(\'Respondent is handling call.\');\r\n}\r\n\r\nclass Manager extends Employee {\r\n  static seniors: Director[];\r\n\r\n  protected getSeniors = () => Manager.seniors;\r\n  protected canHandleCall = () => Math.random() > 0.25;\r\n  protected handleCall = () => console.log(\'Manager is handling call.\');\r\n}\r\n\r\nclass Director extends Employee {\r\n  protected getSeniors = () => [];\r\n  protected canHandleCall = () => true;\r\n  protected handleCall = () => console.log(\'Director is handling call.\');\r\n}\r\n\r\nclass CallCenter {\r\n  constructor(\r\n    private respondents: Respondent[],\r\n    private managers: Manager[],\r\n    private directors: Director[],\r\n  ) {\r\n    Respondent.seniors = this.managers;\r\n    Manager.seniors = this.directors;\r\n  }\r\n\r\n  dispatchCall(call: ICall) {\r\n    const respondent = this.respondents.find(s => s.isFree());\r\n    if (respondent) {\r\n      respondent.receiveCall(call);\r\n    } else {\r\n      console.log(\'Cannot find respondent to handle call.\');\r\n    }\r\n  }\r\n}\r\n\r\ninterface ISong {\r\n  filePath: string;\r\n}\r\n\r\nconst playFile = (filePath: ISong[\'filePath\']) =>\r\n  \/\/ tslint:disable-next-line no-console\r\n  console.log(`Playing: ${filePath}`);\r\n\r\nclass Jukebox {\r\n  static songs: ISong[] = [\r\n    { filePath: \'poop.mp3\' },\r\n    { filePath: \'testing.mp3\' },\r\n  ];\r\n\r\n  readonly playPrice = 2;\r\n  private selectedSongIdx = 0;\r\n  private balance = 0;\r\n\r\n  selectNext() {\r\n    this.selectedSongIdx = Math.min(\r\n      this.selectedSongIdx,\r\n      Jukebox.songs.length - 1,\r\n    );\r\n  }\r\n\r\n  selectPrev() {\r\n    this.selectedSongIdx = Math.max(this.selectedSongIdx, 0);\r\n  }\r\n\r\n  pay(amount: number) {\r\n    this.balance += amount;\r\n  }\r\n\r\n  play() {\r\n    if (!this.canPlay()) throw new Error(\'Not enough balance to pay.\');\r\n    this.balance -= this.playPrice;\r\n    playFile(this.getSelectedSong().filePath);\r\n  }\r\n\r\n  canPlay = () => this.balance >= this.playPrice;\r\n\r\n  getSelectedSong = () => Jukebox.songs[this.selectedSongIdx];\r\n}\r\n\r\nenum VehicleTypes {\r\n  car = \'car\',\r\n  motorbike = \'motorbike\',\r\n  bus = \'bus\',\r\n}\r\n\r\nclass Vehicle {\r\n  constructor(readonly type: VehicleTypes, readonly licensePlate: string) {}\r\n}\r\n\r\nclass ParkingLotLevel {\r\n  constructor(\r\n    private vehicleCapacity: { [vehicleType in VehicleTypes]: number },\r\n    private vehicleStorage: { [vehicleType in VehicleTypes]: Vehicle[] },\r\n  ) {}\r\n\r\n  hasSpaceForVehicleType = (vehicleType: Vehicle[\'type\']) =>\r\n    this.vehicleStorage[vehicleType].length < this.vehicleCapacity[vehicleType];\r\n\r\n  parkVehicle(vehicle: Vehicle) {\r\n    if (!this.hasSpaceForVehicleType(vehicle.type)) {\r\n      throw new Error(`No space for vehicle of type ${vehicle.type}`);\r\n    }\r\n\r\n    this.vehicleStorage[vehicle.type].push(vehicle);\r\n  }\r\n\r\n  unparkVehicle(vehicle: Vehicle) {\r\n    if (!this.vehicleStorage[vehicle.type].includes(vehicle)) {\r\n      throw new Error(\r\n        `Vehicle with license ${vehicle.licensePlate} is not parked here!`,\r\n      );\r\n    }\r\n\r\n    this.vehicleStorage[vehicle.type] = this.vehicleStorage[\r\n      vehicle.type\r\n    ].filter(v => v !== vehicle);\r\n\r\n    return vehicle;\r\n  }\r\n}\r\n\r\nclass ParkingLot {\r\n  private levels: ParkingLotLevel[] = [];\r\n\r\n  hasSpaceForVehicleType = (vehicleType: Vehicle[\'type\']) =>\r\n    !!this.getAvailiableLevel(vehicleType);\r\n\r\n  getAvailiableLevel = (vehicleType: Vehicle[\'type\']) =>\r\n    this.levels.find(l => l.hasSpaceForVehicleType(vehicleType));\r\n}\r\n\r\ntype coord = [number, number];\r\n\r\nconst outsideGrid = (grid: number[][], paintCoord: coord) =>\r\n  paintCoord[0] < 0 ||\r\n  paintCoord[0] >= grid[0].length ||\r\n  paintCoord[1] < 0 ||\r\n  paintCoord[1] >= grid.length;\r\n\r\nconst paintGridCell = (\r\n  grid: number[][],\r\n  paintCoord: coord,\r\n  fillValue: number,\r\n) => {\r\n  const paintedGrid = grid.slice();\r\n  paintedGrid[paintCoord[1]] = paintedGrid[paintCoord[1]].slice();\r\n  paintedGrid[paintCoord[1]][paintCoord[0]] = fillValue;\r\n  return paintedGrid;\r\n};\r\n\r\nconst getAdjacentPaintCoords: (\r\n  paintCoord: coord,\r\n) => Array<typeof paintCoord> = paintCoord => [\r\n  [paintCoord[0], paintCoord[1] - 1],\r\n  [paintCoord[0] + 1, paintCoord[1]],\r\n  [paintCoord[0], paintCoord[1] + 1],\r\n  [paintCoord[0] - 1, paintCoord[1]],\r\n];\r\n\r\nfunction validParenCombinations(\r\n  grid: number[][],\r\n  paintCoord: coord,\r\n  fillValue: number,\r\n  targetValue = grid[paintCoord[1]][paintCoord[0]],\r\n): typeof grid {\r\n  if (outsideGrid(grid, paintCoord)) return grid;\r\n  if (grid[paintCoord[1]][paintCoord[0]] !== targetValue) return grid;\r\n\r\n  const paintedGrid = paintGridCell(grid, paintCoord, fillValue);\r\n\r\n  return getAdjacentPaintCoords(paintCoord).reduce(\r\n    (g, c) => validParenCombinations(g, c, fillValue, targetValue),\r\n    paintedGrid,\r\n  );\r\n}\r\n"
